---
tags:
  - 动态规划
---

给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

- `'.'` 匹配任意单个字符
- `'*'` 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 **整个** 字符串 `s` 的，而不是部分字符串。

示例 1：
输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。

示例 2:
输入：s = "aa", p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

示例 3：
输入：s = "ab", p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

1 <= s.length <= 20
1 <= p.length <= 20
s 只包含从 a-z 的小写字母。
p 只包含从 a-z 的小写字母，以及字符 . 和 *。
保证每次出现字符 * 时，前面都匹配到有效的字符

---

`dp[i][j]` 表示 s 中前i个字符 和 p 中前j个字符能否匹配

* 如果 p 的第 j 个字符是一个小写字母，那么我们必须在 s 中匹配一个相同的小写字母

```
f[i][j] = f[i-1][j-1], 当s[i]==p[j]
          false, 当s[i]!=p[j]
```

也就是说，如果 s 的第 i 个字符与 p 的第 j 个字符不相同，那么无法进行匹配；否则我们可以匹配两个字符串的最后一个字符，完整的匹配结果取决于两个字符串前面的部分。

* 如果 p 的第 j 个字符是 `*`，那么就表示我们可以对 p 的第 j−1 个字符匹配任意自然数次。在匹配 0 次的情况下，我们有

`f[i][j] = f[i][j−2]`

在匹配 1,2,3,⋯ 次的情况下，类似地我们有

```
f[i][j]=f[i−1][j−2], if s[i]=p[j−1]
f[i][j]=f[i−2][j−2], if s[i−1]=s[i]=p[j−1]
f[i][j]=f[i−3][j−2], if s[i−2]=s[i−1]=s[i]=p[j−1]​
```

如果我们通过这种方法进行转移，那么我们就需要枚举这个组合到底匹配了 s 中的几个字符，会增导致时间复杂度增加，并且代码编写起来十分麻烦。我们不妨换个角度考虑这个问题：字母 + 星号的组合在匹配的过程中，本质上只会有两种情况：

匹配 s 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；
不匹配字符，将该组合扔掉，不再进行匹配。
如果按照这个角度进行思考，我们可以写出很精巧的状态转移方程：

```
f[i][j] = f[i-1][j] 或 f[i][j-2], 当s[i]==p[j-1]
          f[i][j-2], 当s[i]!=p[j-1]
```


```C#
public class Solution {
    public bool IsMatch(string s, string p) {
        char[] sArr = s.ToCharArray(), pArr = p.ToCharArray();
        int sLen = sArr.Length, pLen = pArr.Length;
        // 表示 s 中前i个字符 和 p 中前j个字符能否匹配
        bool[,] dp = new bool[sLen + 1, pLen + 1];
        dp[0, 0] = true;
        for (int i = 0; i <= sLen; i++) {
            for (int j = 1; j <= pLen; j++) {
                // 如果 p 的第 j 个字符是一个小写字母，那么我们必须在 s 中匹配一个相同的小写字母
                if (pArr[j-1] != '*') {
                    if (Match(sArr, pArr, i, j)) {
                        dp[i, j] = dp[i-1, j-1];
                    }
                } else {
                    // 和*之前的字符匹配
                    if (Match(sArr, pArr, i, j-1)) {
                        // 使用*匹配 或者 舍弃*匹配
                        dp[i, j] = dp[i-1, j] || dp[i, j-2];
                    } else {
                        // *匹配失败，只能舍弃
                        dp[i, j] = dp[i, j-2];
                    }
                }
            }
        }
        return dp[sLen, pLen];
    }

    public bool Match(char[] sArr, char[] pArr, int i, int j) {
        if (i == 0) return false;
        // 当前是通配符 总是匹配
        if (pArr[j-1] == '.') return true;
        return sArr[i-1] == pArr[j-1];
    }
}
```