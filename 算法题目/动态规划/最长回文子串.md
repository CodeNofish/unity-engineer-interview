---
tags:
  - 动态规划
---

https://leetcode.cn/problems/longest-palindromic-substring/description/

给你一个字符串 `s`，找到 `s` 中最长的 回文 子串。

#### 动态规划

base case，单元素的天然回文。

左边索引一定小于右边索引（子串）所以只有半张表

|     | b   | a   | b   | a   | d   |
| --- | --- | --- | --- | --- | --- |
| b   | 1   |     |     |     |     |
| a   |     | 1   |     |     |     |
| b   |     |     | 1   |     |     |
| a   |     |     |     | 1   |     |
| d   |     |     |     |     | 1   |

确定长度 2，枚举左边界

|     | b   | a   | b   | a   | d   |
| --- | --- | --- | --- | --- | --- |
| b   | 1   | 0   |     |     |     |
| a   |     | 1   | 0   |     |     |
| b   |     |     | 1   | 0   |     |
| a   |     |     |     | 1   | 0   |
| d   |     |     |     |     | 1   |

确定长度 3，枚举左边界

左右元素 要先相等，才有可能是回文；
第二个条件，去掉首位，也就是 `dp[i+1][j-1]` 也得是回文（左下角相邻元素）。

|     | b   | a   | b   | a   | d   |
| --- | --- | --- | --- | --- | --- |
| b   | 1   | 0   | 1   | 0   | 0   |
| a   |     | 1   | 0   | 1   | 0   |
| b   |     |     | 1   | 0   | 0   |
| a   |     |     |     | 1   | 0   |
| d   |     |     |     |     | 1   |

长度确定，枚举左边界，就是斜着填表。


```C#
public class Solution {
    public string LongestPalindrome(string s) {
        if (s.Length < 2) {
            return s;
        }

        int resStartIndex = 0, resLen = 1;
        int n = s.Length;
        bool[,] dp = new bool[n, n];
        char[] chars = s.ToCharArray();
        // base case 单元素天然满足回文
        for (int i = 0; i < n; i++) {
            dp[i, i] = true;
        }
        // 斜着填表
        for (int len = 2; len <= n; len++) {
            for (int i = 0; i < n; i++) {
                // 末尾元素
                int j = i + len - 1;
                // 右边界越界的情况
                if (j >= n) continue;
                // 判断首位元素是否回文
                if (chars[i] == chars[j]) {
                    if (len == 2) { // 左下角没元素时
                        dp[i, j] = true;
                    } else {
                        // 去掉首位元素 也是回文
                        dp[i, j] = dp[i + 1, j - 1];
                    }
                } else {
                    // 首位元素不同 一定不是回文
                    dp[i, j] = false;
                }
                // 收集答案
                if (dp[i, j] && len > resLen) {
                    resStartIndex = i;
                    resLen = len;
                }
            }
        }
        return s.Substring(resStartIndex, resLen);
    }
}
```