
给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。



```C#
public class Solution {
    int n, m;
    int size;
    int[] parents;
    int[] heights;

    public int NumIslands(char[][] grid) {
        n = grid.Length;
        m = grid[0].Length;
        size = n * m;
        parents = new int[n * m];
        heights = new int[n * m];

        // init
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int idx = GetIndex(i,j);
                parents[idx] = idx;
            }
        }

        // union 卷积算子
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == '0') continue;
                int curIdx = GetIndex(i,j);
                if (i != 0 && grid[i-1][j] == '1') {
                    Union(curIdx, GetIndex(i-1, j));
                }
                if (i != n-1 && grid[i+1][j] == '1') {
                    Union(curIdx, GetIndex(i+1, j));
                }
                if (j != 0 && grid[i][j-1] == '1') {
                    Union(curIdx, GetIndex(i, j-1));
                }
                if (j != m-1 && grid[i][j+1] == '1') {
                    Union(curIdx, GetIndex(i, j+1));
                }
            }
        }

        return GetSetCount(grid);
    }

    int Find(int x) {
        while (x != parents[x]) {
            x = parents[x];
        }
        return x;
    }

    void Union(int x, int y) {
        int rx = Find(x), ry = Find(y);
        if (rx == ry) return;
        if (heights[rx] > heights[ry]) {
            parents[ry] = rx;
        } else if (heights[rx] < heights[ry]) {
            parents[rx] = ry;
        } else {
            parents[rx] = ry;;
            heights[ry] = heights[ry] + 1;
        }
    }

    int GetIndex(int i, int j) {
        return i * m + j;
    }

    int GetSetCount(char[][] grid) {
        int cnt = 0;
        // for (int i = 0; i < size; i++) {
        //     if (parents[i] == i) cnt++;
        // }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int idx = GetIndex(i, j);
                if (grid[i][j] == '1' && parents[idx] == idx) {
                    cnt++;
                }
            }
        }
        return cnt;
    }
}
```


加入枝剪 和 count优化

```C#
public class Solution {
    int n, m;
    int size, count;
    int[] parents;
    int[] heights;

    public int NumIslands(char[][] grid) {
        n = grid.Length;
        m = grid[0].Length;
        size = n * m;
        parents = new int[n * m];
        heights = new int[n * m];

        // init
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                // 只计算是岛屿的连通分量
                if (grid[i][j] == '1') {
                    int idx = GetIndex(i,j);
                    parents[idx] = idx;
                    ++count;
                }
            }
        }

        // union 卷积算子
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == '0') continue;
                // 枝剪，防止当前节点，被当做别人的考虑对象 重计算一遍
                grid[i][j] = '0';
                int curIdx = GetIndex(i,j);
                if (i != 0 && grid[i-1][j] == '1') {
                    Union(curIdx, GetIndex(i-1, j));
                }
                if (i != n-1 && grid[i+1][j] == '1') {
                    Union(curIdx, GetIndex(i+1, j));
                }
                if (j != 0 && grid[i][j-1] == '1') {
                    Union(curIdx, GetIndex(i, j-1));
                }
                if (j != m-1 && grid[i][j+1] == '1') {
                    Union(curIdx, GetIndex(i, j+1));
                }
            }
        }

        return count;
    }

    int Find(int x) {
        while (x != parents[x]) {
            x = parents[x];
        }
        return x;
    }

    void Union(int x, int y) {
        int rx = Find(x), ry = Find(y);
        if (rx == ry) return;
        if (heights[rx] > heights[ry]) {
            parents[ry] = rx;
        } else if (heights[rx] < heights[ry]) {
            parents[rx] = ry;
        } else {
            parents[rx] = ry;;
            heights[ry] += 1;
        }
        count--;
    }

    int GetIndex(int i, int j) {
        return i * m + j;
    }

    int GetSetCount(char[][] grid) {
        int cnt = 0;
        // for (int i = 0; i < size; i++) {
        //     if (parents[i] == i) cnt++;
        // }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int idx = GetIndex(i, j);
                if (grid[i][j] == '1' && parents[idx] == idx) {
                    cnt++;
                }
            }
        }
        return cnt;
    }
}
```