https://leetcode.cn/problems/generate-parentheses/description/?envType=problem-list-v2&envId=dynamic-programming

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。


#### 回溯法
递归 + 条件裁剪

```C#
public class Solution {
    public IList<string> GenerateParenthesis(int n) {
        List<string> res = new List<string>();
        char[] current = new char[2 * n];
        Backtrack(current, 0, 0, 0, n, res);
        return res;
    }

    public void Backtrack(char[] current, int pos, int open, int close, int max, List<string> res) {
        if (pos >= current.Length) {
            res.Add(new String(current));
            return;
        }
        // 当前还可以放 open Parentheses
        if (open < max) {
            current[pos] = '(';
            Backtrack(current, pos + 1, open + 1, close, max, res);
            // 回溯情况就是 pos减回来
        }
        // 当前可以放 close Parentheses
        if (close < open) {
            current[pos] = ')';
            Backtrack(current, pos + 1, open, close + 1, max, res);
        }
    }
}
```

#### 暴力法
每个位置放 `(` 或者 `)`，再验证每个生成的结果

```C#
public class Solution {
    public IList<string> GenerateParenthesis(int n) {
        List<string> res = new List<string>();
        char[] current = new char[2 * n];
        GenerateAll(current, 0, res);
        return res;
    }

    public void GenerateAll(char[] current, int pos, List<string> res) {
        if (pos == current.Length) {
            if (IsValid(current)) {
                res.Add(new String(current));
            }
        } else {
            // 当前位置枚举全部情况
            current[pos] = '(';
            GenerateAll(current, pos + 1, res);
            current[pos] = ')';
            GenerateAll(current, pos + 1, res);
        }
    }

    public bool IsValid(char[] current) {
        int balance = 0;
        foreach (char ch in current) {
            if (ch == '(') {
                balance++;
            } else {
                balance--;
            }
            if (balance < 0) {
                return false;
            }
        }
        return balance == 0;
    }
}
```