---
tags:
  - 图
url: https://leetcode.cn/problems/course-schedule/description/?envType=problem-list-v2&envId=graph
---



你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程  `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。

#### 判断有向图 是否有环

边表存储。
访问状态表，未访问，在当前路径的访问中，当前路径访问完毕。

```C#

public class Solution {
    // 判断有向图 是否有环
    public bool CanFinish(int numCourses, int[][] prerequisites) {
        List<List<int>> edges = new List<List<int>>(numCourses);
        // 访问状态表，0未访问，1在当前路径的访问中；2当前路径访问完毕
        int[] visited = new int[numCourses];

        for (int i = 0; i < numCourses; i++) {
            edges.Add(new List<int>());
        }
        foreach (var prerequisit in prerequisites) {
            edges[prerequisit[0]].Add(prerequisit[1]);
        }

        // 遍历
        bool valid = true;
        for (int i = 0; i < numCourses && valid; i++) {
            // 未访问的去访问
            if (visited[i] == 0) {
                dfs(i, edges, visited, ref valid);
            }
        }
        return valid;
    }

    public void dfs(int from, List<List<int>> edges, int[] visited, ref bool valid) {
        visited[from] = 1;
        foreach (int to in edges[from]) {
            if (visited[to] == 0) {
                // 第一次访问
                dfs(to, edges, visited, ref valid);
                if (!valid) return;
            } else if (visited[to] == 1) {
                // 属于之前访问的路径，走到重复节点了 有环
                valid = false;
                return;
            }
        }
        visited[from] = 2;
    }
}

```