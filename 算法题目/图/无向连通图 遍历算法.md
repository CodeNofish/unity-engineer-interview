---
tags:
  - 图遍历
---

#### 深度优先遍历

模拟堆栈时，记得反向加入 保障顺序

```C#
/// <summary>
/// 无向连通图DFS遍历
/// </summary>
public class GraphDFS(Dictionary<int, List<int>> graph) {
  public void DFS(int statVertex) {
    HashSet<int> visited = new();
    DFSRecursive(statVertex, visited);
  }

  private void DFSRecursive(int vertex, HashSet<int> visited) {
    if (visited.Contains(vertex)) {
      return;
    }

    // Do & Record
    Console.WriteLine($"Visiting: {vertex}");
    visited.Add(vertex);

    if (graph.ContainsKey(vertex)) {
      foreach (var neighbor in graph[vertex]) {
        if (!visited.Contains(neighbor)) {
          DFSRecursive(neighbor, visited);
        }
      }
    }
  }

  public void DFSIterative(int startVertex) {
    HashSet<int> visited = new();
    Stack<int> stack = new();

    stack.Push(startVertex);

    while (stack.Count > 0) {
      int currentVertex = stack.Pop();

      if (visited.Contains(currentVertex)) {
        continue;
      }

      // Do & Record
      Console.WriteLine($"Visiting: {currentVertex}");
      visited.Add(currentVertex);

      if (visited.Contains(currentVertex)) {
        var neighbors = graph[currentVertex];
        // 反向加入，保证顺序，LIFO
        for (int i = neighbors.Count - 1; i >= 0; i--) {
          var neighbor = neighbors[i];
          if (!visited.Contains(neighbor)) {
            stack.Push(neighbor);
          }
        }
      }
    }
  }
}
```


#### 无向连通图BFS

```C#
/// <summary>
/// 无向连通图BFS
/// </summary>
public class GraphBFS(Dictionary<int, List<int>> graph) {
  public void BFS(int statVertex) {
    var visited = new HashSet<int>();
    Queue<int> queue = new();
    
    visited.Add(statVertex);
    queue.Enqueue(statVertex);

    while (queue.Count > 0) {
      int currentVertex = queue.Dequeue();
      // Do & Record
      Console.WriteLine($"Visiting: {currentVertex}");
      visited.Add(currentVertex);

      if (graph.ContainsKey(currentVertex)) {
        foreach (var neighbor in graph[currentVertex]) {
          if (!visited.Contains(neighbor)) {
            visited.Add(neighbor);
            queue.Enqueue(neighbor);
          }
        }
      }
    }
  }
}
```


#### 测试

```C#
public class GraphTraversal {  
  [Test]  
  public void TestTraversal() {  
    var graph = new Dictionary<int, List<int>> {  
      [0] = [1, 3],  
      [1] = [0, 2, 4],  
      [2] = [1],  
      [3] = [0, 4],  
      [4] = [1, 3]  
    };  
      
    Console.WriteLine("=== 深度优先搜索 (DFS) ===");  
    var dfs = new GraphDFS(graph);  
    dfs.DFS(0);  
      
    Console.WriteLine("=== 深度优先搜索 (DFS模拟栈) ===");  
    var dfs2 = new GraphDFS(graph);  
    dfs.DFSIterative(0);  
      
    Console.WriteLine("\n=== 广度优先搜索 (BFS) ===");  
    GraphBFS bfs = new GraphBFS(graph);  
    bfs.BFS(0); // 从节点0开始  
  }  
}
```